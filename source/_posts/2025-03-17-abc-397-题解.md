---
title: "abc-397 题解"     
date: 2025-03-17 13:26:10
math: true
tags:
categories: 
  - 比赛 题解
---

## [C - Variety Split Easy](https://atcoder.jp/contests/abc397/tasks/abc397_c)

#### 题目大意

给定一个长度为 $N$ 的整数序列：$A = (A_1, A_2, \dots, A_N)$。

将 $A$ 分成两个非空的连续子数组，求这两个子数组中不同整数的个数之和的最大值。

更正式地，给定一个整数 $i$，其中 $1 \leq i \leq N-1$，要求求出如下两个值的和的最大值：

1. 子数组 $(A_1, A_2, \dots, A_i)$ 中不同整数的个数。
2. 子数组 $(A_{i+1}, A_{i+2}, \dots, A_N)$ 中不同整数的个数。

#### Constraints

-   $2 \leq N \leq 3 \times 10^5$
-   $1 \leq A_i \leq N$ ($1 \leq i \leq N$)
-   All input values are integers.

#### 思路

可以用两个数组 `pre` 和 `bak` 分别表示 从 $1 \sim i$ 子段不同整数个数之和 和 从 $i \sim n$ 子段不同整数个数之和。

通过上面的预处理, 我们便可以快速得知每个切割位置得到两个子段中不同整数个数和, 因此, 遍历每个可切割位点, 更新答案即可。

### CODE

```cpp
void solve()
{
    int n;  cin >> n;
    vector<int> v(n + 1);
    for (int i=1;i<=n;i++)  cin >> v[i];

    vector<int> pre(n + 2, 0), bak(n + 2, 0), mmap(n + 2, 0);
    for (int i=1;i<=n;i++)
    {
        pre[i] = pre[i - 1] + (!mmap[v[i]]);
        mmap[v[i]] ++;
    }
    mmap.assign(mmap.size(), 0);
    for (int i=n;i>=1;i--)
    {
        bak[i] = bak[i + 1] + (!mmap[v[i]]);
        mmap[v[i]] ++;
    }

    int ans = 0;
    for (int i=1;i<n;i++)
        ans = max(ans, pre[i] + bak[i + 1]);
    cout << ans << _endl;
}
```

## [F - Variety Split Hard](https://atcoder.jp/contests/abc397/tasks/abc397_f)

#### 题目大意

给定一个长度为 $N$ 的整数序列：$A = (A_1, A_2, \dots, A_N)$

将 $A$ 分成三个非空的连续子数组，求这三个子数组中不同整数的个数之和的最大值。

更正式地，给定一对整数 $(i, j)$，其中 $1 \leq i < j \leq N-1$，要求求出如下三个值的和的最大值：

1. 子数组 $(A_1, A_2, \dots, A_i)$ 中不同整数的个数。
2. 子数组 $(A_{i+1}, A_{i+2}, \dots, A_j)$ 中不同整数的个数。
3. 子数组 $(A_{j+1}, A_{j+2}, \dots, A_N)$ 中不同整数的个数。

### Constraints

-   $3 \leq N \leq 3 \times 10^5$
-   $1 \leq A_i \leq N$ ($1 \leq i \leq N$)
-   All input values are integers.

#### 思路

类似于 [C](###C - Variety Split Easy) 题的思路, 预处理出 `pre` (从 $1 \sim i$ 子段不同整数个数之和) 和 `bak` (从 $i \sim n$ 子段不同整数个数之和) 数组。

接下来，我们面临的问题是：在 C 题中，只有一个切割点，我们可以在 $\mathcal O(n)$ 的时间内求得答案。但是本题中，存在两个位置的切割点，$\mathcal O(N^2)$ 的时间复杂度，难以快速求解答案，无法满足我们的需求。

我们需要先固定一个切割点(右切割点)：

记 中间子段 不同整数个数的和 为 `f(l, r)`

因此，题目转化为了求
$$
max_{j\in[2, n-1]}\{pre_1 + f(2,j),\ pre_2 + f(3, j),\ pre_3+f(4, j),\ \dots\ ,\ pre_{j-1}+f(j,j)\}\ +\ bak_{j+1}
$$
![image-20250317145720673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250317145720673.png)

观察上面的式子，当 $j$ 变为 $j+1$ 时，

若 $v[j + 1]$ 存在于中间子段， 则其加入无法对中间子段的不同整数的个数产生贡献。

而当 $v[j + 1]$ 不存在于中间子段时， 则其加入将对中间子段不同整数个数产生贡献。

![image-20250317151734254](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250317151734254.png)

因此，我们需要记录当前位置的 $v_i$ 上一次出现的位置 (若前面未曾出现，则为 $0$) 。因此定义 `lst` 数组 记录我们所需信息。

我们再看回 $pre_1 + f(2,j),\ pre_2 + f(3, j),\ pre_3+f(4, j),\ \dots\ ,\ pre_{j-1}+f(j,j)$ 序列：
$$
pre_1 + f(2,j)\qquad pre_2 + f(3, j)\qquad pre_3+f(4, j)\qquad \dots\qquad pre_{j-1}+f(j,j)
\\
pre_1 + f(2,j+1)\qquad pre_2 + f(3, j+1)\qquad pre_3+f(4, j+1)\qquad \dots\qquad pre_{j-1}+f(j,j+1)\qquad pre_{j}+f(j+1,j+1)
$$
可以发现，不仅仅是 `f(l, r)` 右边界扩展了，序列还增加了一项 $pre_{j}+f(j+1,j+1)$ 。

 `f(l, r)` 右边界扩展 当且仅当  $v[j + 1]$ 不存在于中间子段时， 其加入会对 中间子段不同整数个数 产生贡献。 即区间 $[lst_{j+1} + 1, j]$ 中间子段不同整数个数 会加一。

总结一下我们的需求：一个能够快速实现区间修改（处理贡献），区间查询最值（更新答案）的数据结构 —— 线段树！！

### CODE

```cpp
struct Laz
{
    int add = 0;
    void apply(const Laz &tag)
    {
        if (tag.add)
            add += tag.add;
    }
};

struct Info
{
    int mx = 0;
    Info() {}
    Info(int x) : mx(x) {}
    void apply(const Laz &tag, int len)
    {
        if (tag.add)
            mx += tag.add;
    }

    Info operator+ (const Info &a) const
    {
       Info res;
       res.mx = max(mx, a.mx);
       return res;
    }
};

void solve()
{
    int n;  cin >> n;
    vector<int> v(n + 1);
    for (int i=1;i<=n;i++)  cin >> v[i];
    vector<int> pre(n + 2, 0), bak(n + 2, 0), lst(n + 2, 0), mmap(n + 2, 0);
    for (int i=1;i<=n;i++)
    {
        pre[i] = pre[i - 1] + (!mmap[v[i]]);
        lst[i] = mmap[v[i]];
        mmap[v[i]] = i;
    }
    mmap.assign(mmap.size(), 0);
    for (int i=n;i>=1;i--)
    {
        bak[i] = bak[i + 1] + (!mmap[v[i]]);
        mmap[v[i]] = i;
    }

    int ans = 0;
    SegTree<Info, Laz> seg(n);
    for (int j=1;j<=n;j++)
    {
        seg.modify(j, j, {pre[j - 1]});
        seg.modify(lst[j] + 1, j, {1});
        ans = max(ans, seg.query(1, j).mx + bak[j + 1]);
    }
    cout << ans << _endl;
}
```

